.. _SatLiteral:

SatLiteral クラス
=================

SAT ソルバ用の CNF 式のリテラルを表すクラス．
具体的には変数もしくは変数の否定を表す．


情報の取得
----------

以下のコードでは `x`,  `y` は `SatLiteral` 型のオブジェクト
と仮定する．

正常値のチェック
^^^^^^^^^^^^^^^^

::

   b = x.is_valid()

`x` が正常な値を持っている時に `True` を返す．


肯定のリテラルのチェック
^^^^^^^^^^^^^^^^^^^^^^^^

::

   b = x.is_positive()

`x` が肯定のリテラルの場合に `True` を返す．


否定のリテラルのチェック
^^^^^^^^^^^^^^^^^^^^^^^^

::

   b = x.is_negative()

`x` が否定のリテラルの場合に `True` を返す．


変数番号
^^^^^^^^^^^^^^

::

   vid = x.varid

変数番号は 0 以上の整数．
ただしこれは関数ではない．


インデックス値
^^^^^^^^^^^^^^^^^^^^^^^

::

   index = x.index

ユニークなインデックスを返す．
実際には変数番号を２倍して極性を表す1ビットの
情報を加えた数値を返す．
これも関数ではない．


SatLiteral の演算
------------------

肯定のリテラルへ変換する
^^^^^^^^^^^^^^^^^^^^^^^^

::

   y = x.make_positive()

`y` は `x` と同じ変数の肯定のリテラルとなる．
`x` が肯定のリテラルの場合，`y` は `x` と等しくなる．
`x` が否定のリテラルの場合，`y` は `x` を反転したものとなる．


否定のリテラルへ変換する
^^^^^^^^^^^^^^^^^^^^^^^^

::

   y = x.make_negative()

`y` は `x` と同じ変数の否定のリテラルとなる．
`x` が否定のリテラルの場合，`y` は `x` と等しくなる．
`x` が肯定のリテラルの場合，`y` は `x` を反転したものとなる．


極性を反転する
^^^^^^^^^^^^^^

::

   y = ~x


極性を結合する
^^^^^^^^^^^^^^

::

   y = x * p

`p` を Python のブール値に変換して `True` の場合，
`x` の極性を反転させる．
そうでなければ `x` のまま．

等価比較
^^^^^^^^

::

   b = (x == y)

`x` と `y` が等しい時 `b` に `True` が代入される．


非透過比較
^^^^^^^^^^

::

   b = (x != y)

`x` と `y` が等しくない時 `b` に `True` が代入される．
